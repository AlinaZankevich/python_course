# 2. В файле «A_increase.py» создайте класс объектов-итераторов (содержащих метод __next__) RangeIterator для прохода по последовательности строк из решеток возрастающей длины:

# класс объектов-итераторов
# для указания текущего элемента
# в последовательности
import sys


class RangeIterator:
    # при создании создает переменные
    # для хранения текущего состояния
    def __init__(self, size):
        self.x = 0
        self.size = size

    # единственное, что можно делать с итератором -
    # двигать его на следующий элемент последовательности
    # это то, что делает итератор итератором
    def __next__(self):
        self.x += 1
        # если последовательность итератора
        # не бесконечна - должно быть условие
        # для окончания цикла
        if self.x > self.size:
            # для окончания цикла в итераторе
            # вызывается специальное исключение StopIteration
            raise StopIteration
        # возвращает элементы последовательности -
        # строки из решеток заданной длины
        return '#' * self.x


# 3. В файле «A_increase.py» создайте класс итерируемых объектов (содержащих метод __iter__) RangeIterable для применения итератора класса RangeIterator в цикле:

# класс итерируемых объектов
class RangeIterable:
    def __init__(self, size):
        self.size = size

    # для прохода по итерируемому объекту с помощью цикла
    # в начале цикла вызывается метод __iter__
    # для получения итератора
    # это то, что делает объект итерируемым
    def __iter__(self):
        return RangeIterator(self.size)


# 4. В файле «A_increase.py» напишите главную программу для создания
# последовательности (итерируемого объекта класса RangeIterable)
# из 32 строк возрастающей длины и поэлементного вывода ее с помощью цикла
# через короткие интервалы времени:


import time


# главная программа с заголовком,
# позволяющим использовать этот файл как модуль:
if __name__ == '__main__':
    # создание итерируемого объекта
    main_iter = RangeIterable(32)
    # проход по итерируемому объекту с помощью цикла
    for line in main_iter:
        # вывод текущего элемента (который возвращает итератор)
        print(line)
        # задержка между выводами
        time.sleep(0.5)

# 5. Запустите написанную в файле «A_increase.py» программу, полюбуйтесь рисунком в консоли.
#
# 6. На практике для упрощения кода часто объединяют классы итератора и
# итерируемого объекта (в одном классе располагают методы __iter__ и __next__).
# Сделаем это в новом файле «B_decrease.py».
#
# 7. В файле «B_decrease.py» создайте для последовательностей строк из решеток убывающей длины класс RangeIterableIterator, который будет одновременно и итерируемым объектом и итератором по самому себе:

# класс объектов, которые одновременно являюстся и
# итерируемыми (есть метод __iter__),
# и итераторами (есть метод __next__);
# преимущества:
# 1. один класс вместо двух - меньше писать и выдумывать названий
# 2. одно общее состояние - не надо передавать переменные
